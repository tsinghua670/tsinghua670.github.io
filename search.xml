<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-226-翻转二叉树（简单）</title>
      <link href="/2021/02/15/leetcode-226-fan-zhuan-er-cha-shu-jian-dan/"/>
      <url>/2021/02/15/leetcode-226-fan-zhuan-er-cha-shu-jian-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-226-翻转二叉树（简单）"><a href="#LeetCode-226-翻转二叉树（简单）" class="headerlink" title="LeetCode-226-翻转二叉树（简单）"></a>LeetCode-226-翻转二叉树（简单）</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/2021/02/15/leetcode-226-fan-zhuan-er-cha-shu-jian-dan/image-20210215220432039.png" alt="image-20210215220432039"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        这道题目比较简单，只要把二叉树上的每一个节点的左右子节点进行交换，，最后的结果就是完全翻转之后的二叉树，关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//前序遍历,交换</span>        TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//递归交换</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven项目的依赖出现红线解决方式</title>
      <link href="/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/"/>
      <url>/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven项目的依赖出现红线解决方式"><a href="#Maven项目的依赖出现红线解决方式" class="headerlink" title="Maven项目的依赖出现红线解决方式"></a>Maven项目的依赖出现红线解决方式</h1><p>（1）单击File =&gt; Setting菜单项，打开Settings选项卡。</p><p><img src="/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/image-20200724101445812.png" alt="image-20200724101445812"></p><p>（2）在左侧的目录树中，展开Maven节点，重新设置Maven的目录，配置文件路径，以及库Repository路径（前两个设定好，会自动定位到）。</p><p><img src="/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/image-20200724101521236.png" alt="image-20200724101521236"></p><p>（3）接下来就可以通过pom.xml引入你需要的依赖包了，或者直接在原来的项目基础上重新导入包。</p><p><img src="/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/image-20200724101605653.png" alt="image-20200724101605653"></p><p>如果重新导入后还有红线，重新引入一下这个项目</p><p><img src="/2020/07/24/maven-xiang-mu-de-yi-lai-chu-xian-hong-xian-jie-jue-fang-shi/image-20200724101627044.png" alt="image-20200724101627044"></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven项目如何导入本地jar包</title>
      <link href="/2020/07/24/maven-xiang-mu-ru-he-dao-ru-ben-di-jar-bao/"/>
      <url>/2020/07/24/maven-xiang-mu-ru-he-dao-ru-ben-di-jar-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven项目如何导入本地jar包"><a href="#Maven项目如何导入本地jar包" class="headerlink" title="Maven项目如何导入本地jar包"></a>Maven项目如何导入本地jar包</h1><p>新建lib包，之后导入（eclipse直接build path）（idea麻烦些：File→project structure→libraries→+jar包）</p><p><img src="/2020/07/24/maven-xiang-mu-ru-he-dao-ru-ben-di-jar-bao/image-20200724100449904.png" alt="image-20200724100449904">)<img src="/2020/07/24/maven-xiang-mu-ru-he-dao-ru-ben-di-jar-bao/image-20200724100544125.png" alt="image-20200724100544125"></p><p><img src="/2020/07/24/maven-xiang-mu-ru-he-dao-ru-ben-di-jar-bao/image-20200724100640676.png" alt="image-20200724100640676"></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer-03-二维数组的查找</title>
      <link href="/2020/07/23/jian-zhi-offer-03-er-wei-shu-zu-de-cha-zhao/"/>
      <url>/2020/07/23/jian-zhi-offer-03-er-wei-shu-zu-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer-03-二维数组的查找"><a href="#剑指Offer-03-二维数组的查找" class="headerlink" title="剑指Offer-03-二维数组的查找"></a>剑指Offer-03-二维数组的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​         在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则表达式</title>
      <link href="/2020/07/05/java-zheng-ze-biao-da-shi/"/>
      <url>/2020/07/05/java-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="java正则表达式"><a href="#java正则表达式" class="headerlink" title="java正则表达式"></a>java正则表达式</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cxr<span class="token punctuation">.</span>regex<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Matcher<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Pattern<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">regexTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        String qq1 = "0832137835";</span><span class="token comment" spellcheck="true">//        String qq2 = "17582236578";</span><span class="token comment" spellcheck="true">//        String qq3 = "15823585";</span><span class="token comment" spellcheck="true">//        System.out.println("q1=" + isNumber(qq1));</span><span class="token comment" spellcheck="true">//        System.out.println("q2=" + isNumber(qq2));</span><span class="token comment" spellcheck="true">//        System.out.println("q3=" + isNumber(qq3));</span><span class="token comment" spellcheck="true">//        splitDemo1();</span><span class="token comment" spellcheck="true">//        replaceDemo1();</span><span class="token comment" spellcheck="true">//        getDemo();</span>        <span class="token function">testRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//正则表达式的练习：</span>    <span class="token comment" spellcheck="true">//将下面的字符串“我我我……我我……爱…爱爱……学…学……学编程”改为：“我爱学编程”</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"我我我.........我我........爱......爱爱............学...学...............学编程"</span><span class="token punctuation">;</span>        String reg <span class="token operator">=</span> <span class="token string">"\\.+"</span><span class="token punctuation">;</span>        String newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        reg <span class="token operator">=</span> <span class="token string">"(.)\\1+"</span><span class="token punctuation">;</span>        String str1 <span class="token operator">=</span> newStr<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"ming tain jiu yao fang jia le,da jia."</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取四个字母的单词</span>        String reg <span class="token operator">=</span> <span class="token string">"\\b[a-z]{4}\\b"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将规则封装成对象</span>        Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将正则对象和要作用的字符串相关联。获取匹配器对象。</span>        Matcher matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"句子中由四个字母组成的单词有："</span> <span class="token operator">+</span> matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//替换</span>    <span class="token comment" spellcheck="true">//将“张三@@@李四YYY王五*****王尼玛”中的叠词替换为单字符，即结果为：“张三@李四Y王五*王尼玛”</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">replaceDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"张三@@@李四YYY王五*****王尼玛"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//匹配规则</span>        String regex <span class="token operator">=</span> <span class="token string">"(.)\\1+"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用$1来复用组中第1组的值</span>        String newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//第三：将字符串“张三@@@李四YYY王五*****王尼玛”中的叠词替换为：“、”</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">replaceDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"张三@@@李四YYY王五*****王尼玛"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//匹配规则(使用$1来复用组中第1组的值)</span>        String regex <span class="token operator">=</span> <span class="token string">"(.)\\1+"</span><span class="token punctuation">;</span>        String newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">"、"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//切割</span>    <span class="token comment" spellcheck="true">/**     * 【以叠词切割】：如字符串"abccsasahhhz"按“叠词”来切割就变成了“ab”，“sasa”，“z”。     * 因为“cc”、“hhh”都是叠词，需要切割掉。现在请将字符串“张三@@@李四￥￥王五ssssssss江流儿”按照叠词切割。     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">splitDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"张三@@@李四￥￥王五ssssssss江流儿"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * "(.)\\1"就表示：某一字符出现了两次(注意首先我们用(.)来表示任意字符，         * 而\\1是对组(.)中的字符进行复用，合起来就是：两个相同的字符)，         * 现在我们不只是需要出现两次的字符，所以使用+号来表示出现多次，最终叠词就表示为：regex = "(.)\\1+"。         */</span>        String reg <span class="token operator">=</span> <span class="token string">"(.)\\1+"</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//第二：对字符串“张三@@@李四@@王五@茅台”进行切割，去掉@符号</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">splitDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"张三@@@李四@@王五@茅台"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//描述切割规则：以若干@来切割</span>        String reg <span class="token operator">=</span> <span class="token string">"@+"</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String string <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//匹配</span>    <span class="token comment" spellcheck="true">/*     * 匹配电话号码（匹配成功的电话号码位数为11位的纯数字，     * 且以1开头，第二位必须是：3、7、8中的一位，     * 即只匹配13*********、17*********、18*********的电话号码）     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>String number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String regex <span class="token operator">=</span> <span class="token string">"1[378][0-9]{9}"</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> b <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//第一：匹配QQ号（长度5-10位，纯数字组成，且不能以0开头）</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isQQ</span><span class="token punctuation">(</span>String qq<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String regex <span class="token operator">=</span> <span class="token string">"[1-9][0-9]{4,9}"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        String regex = "[a-z]\\d";</span>        <span class="token keyword">boolean</span> b <span class="token operator">=</span> qq<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/07/05/er-fen-cha-zhao/"/>
      <url>/2020/07/05/er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>适用于有序数组，先求数组中间元素，若是所输入值比中间值小，则查询中间值前的数组元素，反之则查询后半部分，以此类推，直至找到查询元素</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> from<span class="token punctuation">,</span><span class="token keyword">int</span> to<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>to <span class="token operator">==</span> from<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token punctuation">(</span>to <span class="token operator">-</span> from<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        to <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">></span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        from <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地项目部署到github</title>
      <link href="/2020/06/28/jiang-ben-di-xiang-mu-bu-shu-dao-github/"/>
      <url>/2020/06/28/jiang-ben-di-xiang-mu-bu-shu-dao-github/</url>
      
        <content type="html"><![CDATA[<h1 id="将本地项目部署到github"><a href="#将本地项目部署到github" class="headerlink" title="将本地项目部署到github"></a>将本地项目部署到github</h1><ol><li><h2 id="在本地创建一个文件夹"><a href="#在本地创建一个文件夹" class="headerlink" title="在本地创建一个文件夹"></a>在本地创建一个文件夹</h2></li><li><h2 id="在文件夹内打开git-bash，然后初始化文件夹"><a href="#在文件夹内打开git-bash，然后初始化文件夹" class="headerlink" title="在文件夹内打开git bash，然后初始化文件夹"></a>在文件夹内打开git bash，然后初始化文件夹</h2><pre><code>git init #初始化一个仓库</code></pre></li></ol><ol start="3"><li><h2 id="将需要上传的项目内容复制到已初始化文件夹内"><a href="#将需要上传的项目内容复制到已初始化文件夹内" class="headerlink" title="将需要上传的项目内容复制到已初始化文件夹内"></a>将需要上传的项目内容复制到已初始化文件夹内</h2></li><li><h2 id="在github上创建一个新的仓库（最好与自己创建的文件名相同）"><a href="#在github上创建一个新的仓库（最好与自己创建的文件名相同）" class="headerlink" title="在github上创建一个新的仓库（最好与自己创建的文件名相同）"></a>在github上创建一个新的仓库（最好与自己创建的文件名相同）</h2></li><li><h2 id="将项目上传到github仓库中，依次输入以下命令"><a href="#将项目上传到github仓库中，依次输入以下命令" class="headerlink" title="将项目上传到github仓库中，依次输入以下命令"></a>将项目上传到github仓库中，依次输入以下命令</h2><pre><code>git add . #将项目加入暂存区git commit -m &quot;first commit(可以自定义)&quot; #提交到仓库git remote add origin 仓库路径 #github仓库与本地仓库关联git push -u origin master #将内容推送到远程仓库，第二次后不用再加 -u 参数</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何將本地項目部署到github Page上</title>
      <link href="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/"/>
      <url>/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="如何將本地項目部署到github-Page上"><a href="#如何將本地項目部署到github-Page上" class="headerlink" title="如何將本地項目部署到github Page上"></a>如何將本地項目部署到github Page上</h1><h2 id="一、创建一个新的仓库"><a href="#一、创建一个新的仓库" class="headerlink" title="一、创建一个新的仓库"></a>一、创建一个新的仓库</h2><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516222711133.png" alt="image-20200516222711133">)<img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516222818807.png" alt="image-20200516222818807"></p><h2 id="二、设置GitHub-Pages"><a href="#二、设置GitHub-Pages" class="headerlink" title="二、设置GitHub Pages"></a>二、设置GitHub Pages</h2><p>打开仓库选择设置</p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516223036363.png" alt="image-20200516223036363"></p><p>找到GitHub Pages设置：选择change theme，随便一个主题，然后保存。即可生成一个可访问网址</p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516225057431.png" alt="image-20200516225057431"></p><h2 id="三、将创建的仓库克隆到本地"><a href="#三、将创建的仓库克隆到本地" class="headerlink" title="三、将创建的仓库克隆到本地"></a>三、将创建的仓库克隆到本地</h2><p>打开此电脑，选择一个盘符，空白处鼠标右键 git bash here（前提是git已经安装好），创建一个文件夹（名字随意），进入新创建的文件夹</p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516223725968.png" alt="image-20200516223725968">)<img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516223832038.png" alt="image-20200516223832038"></p><p>将仓库的链接复制，然后克隆到该文件夹下，git clone …..，然后进入新克隆的文件下</p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516224250030.png" alt="image-20200516224250030"></p><h2 id="四、上传本地项目到仓库"><a href="#四、上传本地项目到仓库" class="headerlink" title="四、上传本地项目到仓库"></a>四、上传本地项目到仓库</h2><p>将自己的项目文件拷贝到刚克隆的仓库文件中，然后按顺序执行以下命令：</p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516224506560.png" alt="image-20200516224506560"></p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516224620176.png" alt="image-20200516224620176"></p><p><img src="/2020/05/16/ru-he-jiang-ben-di-xiang-mu-bu-shu-dao-github-page-shang/image-20200516224723191.png" alt="image-20200516224723191"></p><p>最后进入github仓库页面刷新以下，即可看到成功的页面。</p><p>用GitHub Pages上的网页即可访问效果图。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2020/05/10/kuai-su-pai-xu/"/>
      <url>/2020/05/10/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/05/10/gui-bing-pai-xu/"/>
      <url>/2020/05/10/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1.先将需排序的数据分成两个长度子数组，</p><p>2.然后用递归的方式将分开后的两个子数组排序成两个有序的数组，</p><p>3.创建一个新的辅助数组，大小与原数组相同，分别用两指针遍历两个子数组，比较两数组指针所指元素，小的放入新数组中，以此类推，最后将两个子数组的元素全部放进辅助数组</p><p>4.最后将辅助数组的元素拷贝回原数组</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> lef<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lef <span class="token operator">==</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> lef<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>lef<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> L<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>R<span class="token operator">-</span>L<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>lenght<span class="token operator">-</span><span class="token number">1</span>；i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>L<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2020/05/10/cha-ru-pai-xu/"/>
      <url>/2020/05/10/cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序（java实现）"><a href="#插入排序（java实现）" class="headerlink" title="插入排序（java实现）"></a>插入排序（java实现）</h1><ol><li><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>將第一個元素看作一個有序的序列，把第二個元素到最後一個元素當作未排序序列</p></li><li><p>從頭到尾依次掃描未排序序列，將掃描到的每個元素插入有序序列的適當位置。（如果待插入元素與有序序列的某個元素相等，則將待插入元素插入到相等元素的後面）</p></li></ol></li></ol><ol start="2"><li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_InsertSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ol><pre><code>   public static void main(String[] args) {       // TODO Auto-generated method stub   }</code></pre><p>   }</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk8新特性</title>
      <link href="/2020/05/10/jdk8-xin-te-xing/"/>
      <url>/2020/05/10/jdk8-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性"></a>JDK1.8的新特性</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>JDK1.8已经发布很久了，在很多企业中都已经在使用。并且Spring5、SpringBoot2.0都推荐使用JDK1.8以上版本。所以我们必须与时俱进，拥抱变化。</p><p>Jdk8这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习以下方面的新特性：</p><ul><li>[Lambda表达式](#2. Lambda表达式)</li><li>[函数式接口](#3. 函数式接口)</li><li>[方法引用](#4. 方法引用)</li><li>[接口的默认方法和静态方法](#5. 接口的默认方法和静态方法)</li><li>[Optional](#6. Optional)</li><li>[Streams](#7. Streams)</li><li>[并行数组](#8. 并行数组)</li></ul><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><p>函数式编程</p><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。可以使代码变的更加简洁紧凑。</p><h3 id="2-1-基本语法："><a href="#2-1-基本语法：" class="headerlink" title="2.1 基本语法："></a>2.1 基本语法：</h3><pre><code>(参数列表) -&gt; {代码块}</code></pre><p>需要注意：</p><ul><li>参数类型可省略，编译器可以自己推断</li><li>如果只有一个参数，圆括号可以省略</li><li>代码块如果只是一行代码，大括号也可以省略</li><li>如果代码块是一行，且是有结果的表达式，<code>return</code>可以省略</li></ul><p><strong>注意：</strong>事实上，把Lambda表达式可以看做是匿名内部类的一种简写方式。当然，前提是这个匿名内部类对应的必须是接口，而且接口中必须只有一个函数！Lambda表达式就是直接编写函数的：参数列表、代码体、返回值等信息，<strong><code>用函数来代替完整的匿名内部类</code></strong>！</p><h3 id="2-2-用法示例"><a href="#2-2-用法示例" class="headerlink" title="2.2 用法示例"></a>2.2 用法示例</h3><h5 id="示例1：多个参数"><a href="#示例1：多个参数" class="headerlink" title="示例1：多个参数"></a>示例1：多个参数</h5><p>准备一个集合：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 准备一个集合</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>假设我们要对集合排序，我们先看JDK7的写法，需要通过匿名内部类来构造一个<code>Comparator</code>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Jdk1.7写法</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer o1<span class="token punctuation">,</span> Integer o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o1 <span class="token operator">-</span> o2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [-15, 5, 10, 20, 25]</span></code></pre><p>如果是jdk8，我们可以使用新增的集合API：<code>sort(Comparator c)</code>方法，接收一个比较器，我们用Lambda来代替<code>Comparator</code> 的匿名内部类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Jdk1.8写法，参数列表的数据类型可省略：</span>list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i1<span class="token punctuation">,</span>i2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i1 <span class="token operator">-</span> i2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [-15, 5, 10, 20, 25]</span></code></pre><p>对比一下<code>Comparator</code>中的<code>compare()</code>方法，你会发现：这里编写的Lambda表达式，恰恰就是<code>compare()</code>方法的简写形式，JDK8会把它编译为匿名内部类。是不是简单多了！</p><p>别着急，我们发现这里的代码块只有一行代码，符合前面的省略规则，我们可以简写为：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Jdk8写法</span><span class="token comment" spellcheck="true">// 因为代码块是一个有返回值的表达式，可以省略大括号以及return</span>list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i1<span class="token punctuation">,</span>i2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> i1 <span class="token operator">-</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="示例2：单个参数"><a href="#示例2：单个参数" class="headerlink" title="示例2：单个参数"></a>示例2：单个参数</h5><p>还以刚才的集合为例，现在我们想要遍历集合中的元素，并且打印。</p><p>先用jdk1.7的方式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// JDK1.7遍历并打印集合</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Integer i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>jdk1.8给集合添加了一个方法：<code>foreach()</code> ，接收一个对元素进行操作的函数：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// JDK1.8遍历并打印集合，因为只有一个参数，所以我们可以省略小括号:</span>list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="实例3：把Lambda赋值给变量"><a href="#实例3：把Lambda赋值给变量" class="headerlink" title="实例3：把Lambda赋值给变量"></a>实例3：把Lambda赋值给变量</h5><p>Lambda表达式的实质其实还是匿名内部类，所以我们其实可以把Lambda表达式赋值给某个变量。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将一个Lambda表达式赋值给某个接口：</span>Runnable task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里其实是Runnable接口的匿名内部类，我们在编写run方法。</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello lambda!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>不过上面的用法很少见，一般都是直接把Lambda作为参数。</p><h5 id="示例4：隐式final"><a href="#示例4：隐式final" class="headerlink" title="示例4：隐式final"></a>示例4：隐式final</h5><p>Lambda表达式的实质其实还是匿名内部类，而匿名内部类在访问外部局部变量时，要求变量必须声明为<code>final</code>！不过我们在使用Lambda表达式时无需声明<code>final</code>，这并不是说违反了匿名内部类的规则，因为Lambda底层会隐式的把变量设置为<code>final</code>，在后续的操作中，一定不能修改该变量：</p><p>正确示范：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个局部变量</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Runnable r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在Lambda表达式中使用局部变量num，num会被隐式声明为final</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// -1</span></code></pre><p>错误案例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 定义一个局部变量</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Runnable r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在Lambda表达式中使用局部变量num，num会被隐式声明为final，不能进行任何修改操作</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//报错</span></code></pre><h2 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h2><p>经过前面的学习，相信大家对于Lambda表达式已经有了初步的了解。总结一下：</p><ul><li>Lambda表达式是接口的匿名内部类的简写形式</li><li>接口必须满足：内部只有一个函数</li></ul><p>其实这样的接口，我们称为函数式接口，我们学过的<code>Runnable</code>、<code>Comparator</code>都是函数式接口的典型代表。但是在实践中，函数接口是非常脆弱的，只要有人在接口里添加多一个方法，那么这个接口就不是函数接口了，就会导致编译失败。Java 8提供了一个特殊的注解<code>@FunctionalInterface</code>来克服上面提到的脆弱性并且显示地表明函数接口。而且jdk8版本中，对很多已经存在的接口都添加了<code>@FunctionalInterface</code>注解，例如<code>Runnable</code>接口：</p><p><img src="/2020/05/10/jdk8-xin-te-xing/runnable.png" alt="1"></p><p>另外，Jdk8默认提供了一些函数式接口供我们使用：</p><h3 id="3-1-Function类型接口"><a href="#3-1-Function类型接口" class="headerlink" title="3.1 Function类型接口"></a>3.1 Function类型接口</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接收一个参数T，返回一个结果R</span>    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Function代表的是有参数，有返回值的函数。还有很多类似的Function接口：</p><table><thead><tr><th align="left">接口名</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>BiFunction&lt;T,U,R&gt;</code></td><td>接收两个T和U类型的参数，并且返回R类型结果的函数</td></tr><tr><td align="left"><code>DoubleFunction&lt;R&gt;</code></td><td>接收double类型参数，并且返回R类型结果的函数</td></tr><tr><td align="left"><code>IntFunction&lt;R&gt;</code></td><td>接收int类型参数，并且返回R类型结果的函数</td></tr><tr><td align="left"><code>LongFunction&lt;R&gt;</code></td><td>接收long类型参数，并且返回R类型结果的函数</td></tr><tr><td align="left"><code>ToDoubleFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回double类型结果</td></tr><tr><td align="left"><code>ToIntFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回int类型结果</td></tr><tr><td align="left"><code>ToLongFunction&lt;T&gt;</code></td><td>接收T类型参数，并且返回long类型结果</td></tr><tr><td align="left"><code>DoubleToIntFunction</code></td><td>接收double类型参数，返回int类型结果</td></tr><tr><td align="left"><code>DoubleToLongFunction</code></td><td>接收double类型参数，返回long类型结果</td></tr></tbody></table><p>看出规律了吗？这些都是一类函数接口，在Function基础上衍生出的，要么明确了参数不确定返回结果，要么明确结果不知道参数类型，要么两者都知道。</p><h3 id="3-2-Consumer系列"><a href="#3-2-Consumer系列" class="headerlink" title="3.2 Consumer系列"></a>3.2 Consumer系列</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接收T类型参数，不返回结果</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Consumer系列与Function系列一样，有各种衍生接口，这里不一一列出了。不过都具备类似的特征：那就是不返回任何结果。</p><h3 id="3-3-Predicate系列"><a href="#3-3-Predicate系列" class="headerlink" title="3.3 Predicate系列"></a>3.3 Predicate系列</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接收T类型参数，返回boolean类型结果</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Predicate系列参数不固定，但是返回的一定是boolean类型。</p><h3 id="3-4-Supplier系列"><a href="#3-4-Supplier系列" class="headerlink" title="3.4 Supplier系列"></a>3.4 Supplier系列</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 无需参数，返回一个T类型结果</span>    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Supplier系列，英文翻译就是“供应者”，顾名思义：只产出，不收取。所以不接受任何参数，返回T类型结果。</p><h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><p>方法引用使得开发者可以将已经存在的方法作为变量来传递使用。方法引用可以和Lambda表达式配合使用。</p><h3 id="4-1-语法："><a href="#4-1-语法：" class="headerlink" title="4.1 语法："></a>4.1 语法：</h3><p>总共有四类方法引用：</p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>类名::静态方法名</td><td>类的静态方法的引用</td></tr><tr><td>类名::非静态方法名</td><td>类的非静态方法的引用</td></tr><tr><td>实例对象::非静态方法名</td><td>类的指定实例对象的非静态方法引用</td></tr><tr><td>类名::new</td><td>类的构造方法引用</td></tr></tbody></table><h3 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h3><p>首先我们编写一个集合工具类，提供一个方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionUtil</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 利用function将list集合中的每一个元素转换后形成新的集合返回         * @param list 要转换的源集合         * @param function 转换元素的方式         * @param &lt;T> 源集合的元素类型         * @param &lt;R> 转换后的元素类型         * @return         */</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span>R<span class="token operator">></span> List<span class="token operator">&lt;</span>R<span class="token operator">></span> <span class="token function">convert</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>R<span class="token operator">></span> function<span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>R<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>t <span class="token operator">-</span><span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>可以看到这个方法接收两个参数：</p><ul><li><code>List&lt;T&gt; list</code>：需要进行转换的集合</li><li><code>Function&lt;T,R&gt;</code>：函数接口，接收T类型，返回R类型。用这个函数接口对list中的元素T进行转换，变为R类型</li></ul><p>接下来，我们看具体案例：</p><h4 id="4-2-1-类的静态方法引用"><a href="#4-2-1-类的静态方法引用" class="headerlink" title="4.2.1 类的静态方法引用"></a>4.2.1 类的静态方法引用</h4><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们需要把这个集合中的元素转为十六进制保存，需要调用<code>Integer.toHexString()</code>方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">toUnsignedString0</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法接收一个 i 类型，返回一个<code>String</code>类型，可以用来构造一个<code>Function</code>的函数接口：</p><p>我们先按照Lambda原始写法，传入的Lambda表达式会被编译为<code>Function</code>接口，接口中通过<code>Integer.toHexString(i)</code>对原来集合的元素进行转换：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过Lambda表达式实现</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> hexList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hexList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [3e8, 7d0, bb8]</span></code></pre><p>上面的Lambda表达式代码块中，只有对<code>Integer.toHexString()</code>方法的引用，没有其它代码，因此我们可以直接把方法作为参数传递，由编译器帮我们处理，这就是静态方法引用：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 类的静态方法引用</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> hexList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>toHexString<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hexList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [3e8, 7d0, bb8]</span></code></pre><h4 id="4-2-2-类的非静态方法引用"><a href="#4-2-2-类的非静态方法引用" class="headerlink" title="4.2.2 类的非静态方法引用"></a>4.2.2 类的非静态方法引用</h4><p>接下来，我们把刚刚生成的<code>String</code>集合<code>hexList</code>中的元素都变成大写，需要借助于String类的toUpperCase()方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">toUpperCase</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这次是非静态方法，不能用类名调用，需要用实例对象，因此与刚刚的实现有一些差别，我们接收集合中的每一个字符串<code>s</code>。但与上面不同然后<code>s</code>不是<code>toUpperCase()</code>的参数，而是调用者：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过Lambda表达式，接收String数据，调用toUpperCase()</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> upperList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>hexList<span class="token punctuation">,</span> s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>upperList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [3E8, 7D0, BB8]</span></code></pre><p>因为代码体只有对<code>toUpperCase()</code>的调用，所以可以把方法作为参数引用传递，依然可以简写：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 类的成员方法</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> upperList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>hexList<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>upperList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [3E8, 7D0, BB8]</span></code></pre><h4 id="4-2-3-指定实例的非静态方法引用"><a href="#4-2-3-指定实例的非静态方法引用" class="headerlink" title="4.2.3 指定实例的非静态方法引用"></a>4.2.3 指定实例的非静态方法引用</h4><p>下面一个需求是这样的，我们先定义一个数字<code>Integer num = 2000</code>，然后用这个数字和集合中的每个数字进行比较，比较的结果放入一个新的集合。比较对象，我们可以用<code>Integer</code>的<code>compareTo</code>方法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Integer anotherInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> anotherInteger<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先用Lambda实现，</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 某个对象的成员方法</span>Integer num <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> compareList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> num<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>compareList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [1, 0, -1]</span></code></pre><p>与前面类似，这里Lambda的代码块中，依然只有对<code>num.compareTo(i)</code>的调用，所以可以简写。但是，需要注意的是，这次方法的调用者不是集合的元素，而是一个外部的局部变量<code>num</code>，因此不能使用 <code>Integer::compareTo</code>，因为这样是无法确定方法的调用者。要指定调用者，需要用 <code>对象::方法名</code>的方式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 某个对象的成员方法</span>Integer num <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> compareList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> num<span class="token operator">:</span><span class="token operator">:</span>compareTo<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>compareList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [1, 0, -1]</span></code></pre><h4 id="4-2-4-构造函数引用"><a href="#4-2-4-构造函数引用" class="headerlink" title="4.2.4 构造函数引用"></a>4.2.4 构造函数引用</h4><p>最后一个场景：把集合中的数字作为毫秒值，构建出<code>Date</code>对象并放入集合，这里我们就需要用到Date的构造函数：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**  * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.  * @see     java.lang.System#currentTimeMillis()  */</span><span class="token keyword">public</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">long</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fastTime <span class="token operator">=</span> date<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们可以接收集合中的每个元素，然后把元素作为<code>Date</code>的构造函数参数：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将数值类型集合，转为Date类型</span>List<span class="token operator">&lt;</span>Date<span class="token operator">></span> dateList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这里遍历元素后需要打印，因此直接把println作为方法引用传递了</span>dateList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的Lambda表达式实现方式，代码体只有<code>new Date()</code>一行代码，因此也可以采用方法引用进行简写。但问题是，构造函数没有名称，我们只能用<code>new</code>关键字来代替：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 构造方法</span>List<span class="token operator">&lt;</span>Date<span class="token operator">></span> dateList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> Date<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dateList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意两点：</p><ul><li>上面代码中的System.out::println 其实是 指定对象System.out的非静态方法println的引用</li><li>如果构造函数有多个，可能无法区分导致传递失败</li></ul><h2 id="5-接口的默认方法和静态方法"><a href="#5-接口的默认方法和静态方法" class="headerlink" title="5. 接口的默认方法和静态方法"></a>5. 接口的默认方法和静态方法</h2><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。</p><h3 id="5-1-默认方法"><a href="#5-1-默认方法" class="headerlink" title="5.1 默认方法"></a>5.1 默认方法</h3><p>默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or </span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p><h3 id="5-2-静态方法"><a href="#5-2-静态方法" class="headerlink" title="5.2 静态方法"></a>5.2 静态方法</h3><p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，我们可以直接用接口调用这些静态方法。例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">DefaulableFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow static methods</span>    <span class="token keyword">static</span> Defaulable <span class="token function">create</span><span class="token punctuation">(</span> Supplier<span class="token operator">&lt;</span> Defaulable <span class="token operator">></span> supplier <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的代码片段整合了默认方法和静态方法的使用场景：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用接口的静态方法，并且传递DefaultableImpl的构造函数引用来构建对象</span>    Defaulable defaulable <span class="token operator">=</span> DefaulableFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> DefaultableImpl<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> defaulable<span class="token punctuation">.</span><span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用接口的静态方法，并且传递OverridableImpl的构造函数引用来构建对象</span>    defaulable <span class="token operator">=</span> DefaulableFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> OverridableImpl<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> defaulable<span class="token punctuation">.</span><span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码的输出结果如下：</p><pre><code>Default implementationOverridden implementation</code></pre><p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给<code>java.util.Collection</code>接口添加新方法，如<code>stream()</code>、<code>parallelStream()</code>、<code>forEach()</code>和<code>removeIf()</code>等等。</p><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p><h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h2><p>Java应用中最常见的bug就是空值异常。</p><p><code>Optional</code>仅仅是一个容器，可以存放T类型的值或者<code>null</code>。它提供了一些有用的接口来避免显式的<code>null</code>检查，可以参考Java 8官方文档了解更多细节。</p><p>接下来看一点使用Optional的例子：可能为空的值或者某个类型的值：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span> String <span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span> null <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span> <span class="token string">"Hey Stranger!"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果<code>Optional</code>实例持有一个非空值，则<code>isPresent()</code>方法返回<code>true</code>，否则返回<code>false</code>；如果<code>Optional</code>实例持有<code>null</code>，<code>orElseGet()</code>方法可以接受一个lambda表达式生成的默认值；<code>map()</code>方法可以将现有的<code>Optional</code>实例的值转换成新的值；<code>orElse()</code>方法与<code>orElseGet()</code>方法类似，但是在持有null的时候返回传入的默认值，而不是通过Lambda来生成。</p><p>上述代码的输出结果如下：</p><pre><code>Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>再看下另一个简单的例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span> String <span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span> <span class="token string">"Tom"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span> <span class="token string">"Hey Stranger!"</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个例子的输出是：</p><pre><code>First Name is set? trueFirst Name: TomHey Tom!</code></pre><p>如果想了解更多的细节，请参考官方文档。</p><h2 id="7-Streams"><a href="#7-Streams" class="headerlink" title="7. Streams"></a>7. Streams</h2><p>新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p><p>Steam API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Streams</span>  <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">enum</span> Status <span class="token punctuation">{</span>        OPEN<span class="token punctuation">,</span> CLOSED    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Status status<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Integer points<span class="token punctuation">;</span>        <span class="token function">Task</span><span class="token punctuation">(</span> <span class="token keyword">final</span> Status status<span class="token punctuation">,</span> <span class="token keyword">final</span> Integer points <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>points <span class="token operator">=</span> points<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Integer <span class="token function">getPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> points<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Status <span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> status<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span> <span class="token string">"[%s, %d]"</span><span class="token punctuation">,</span> status<span class="token punctuation">,</span> points <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Task类有一个points属性，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Collection<span class="token operator">&lt;</span> Task <span class="token operator">></span> tasks <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>    <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span> Status<span class="token punctuation">.</span>OPEN<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span> Status<span class="token punctuation">.</span>OPEN<span class="token punctuation">,</span> <span class="token number">13</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span> Status<span class="token punctuation">.</span>CLOSED<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>首先看一个问题：在这个task集合中一共有多少个OPEN状态的？计算出它们的points属性和。在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate total points of all active tasks using sum()</span><span class="token keyword">final</span> <span class="token keyword">long</span> totalPointsOfOpenTasks <span class="token operator">=</span> tasks    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span> task <span class="token operator">-</span><span class="token operator">></span> task<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Status<span class="token punctuation">.</span>OPEN <span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span> Task<span class="token operator">:</span><span class="token operator">:</span>getPoints <span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"Total points: "</span> <span class="token operator">+</span> totalPointsOfOpenTasks <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行这个方法的控制台输出是：</p><pre><code>Total points: 18</code></pre><p>这里有很多知识点值得说。首先，<code>tasks</code>集合被转换成<code>steam</code>表示；其次，在<code>steam</code>上的<code>filter</code>操作会过滤掉所有<code>CLOSED</code>的<code>task</code>；第三，<code>mapToInt</code>操作基于<code>tasks</code>集合中的每个<code>task</code>实例的<code>Task::getPoints</code>方法将<code>task</code>流转换成<code>Integer</code>集合；最后，通过<code>sum</code>方法计算总和，得出最后的结果。</p><p>在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。</p><p>中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p><p>晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。</p><p>steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有task的points之和：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate total points of all tasks</span><span class="token keyword">final</span> <span class="token keyword">double</span> totalPoints <span class="token operator">=</span> tasks   <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> task <span class="token operator">-</span><span class="token operator">></span> task<span class="token punctuation">.</span><span class="token function">getPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// or map( Task::getPoints ) </span>   <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"Total points (all tasks): "</span> <span class="token operator">+</span> totalPoints <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下：</p><pre><code>Total points（all tasks）: 26.0</code></pre><p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Group tasks by their status</span><span class="token keyword">final</span> Map<span class="token operator">&lt;</span> Status<span class="token punctuation">,</span> List<span class="token operator">&lt;</span> Task <span class="token operator">></span> <span class="token operator">></span> map <span class="token operator">=</span> tasks    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span> Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span> Task<span class="token operator">:</span><span class="token operator">:</span>getStatus <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> map <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>控制台的输出如下：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>CLOSED<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span>CLOSED<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> OPEN<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span>OPEN<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>OPEN<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate the weight of each tasks (as percent of total points) </span><span class="token keyword">final</span> Collection<span class="token operator">&lt;</span> String <span class="token operator">></span> result <span class="token operator">=</span> tasks    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                        <span class="token comment" spellcheck="true">// Stream&lt; String ></span>    <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span> Task<span class="token operator">:</span><span class="token operator">:</span>getPoints <span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">// IntStream</span>    <span class="token punctuation">.</span><span class="token function">asLongStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                  <span class="token comment" spellcheck="true">// LongStream</span>    <span class="token punctuation">.</span><span class="token function">mapToDouble</span><span class="token punctuation">(</span> points <span class="token operator">-</span><span class="token operator">></span> points <span class="token operator">/</span> totalPoints <span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// DoubleStream</span>    <span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                         <span class="token comment" spellcheck="true">// Stream&lt; Double ></span>    <span class="token punctuation">.</span><span class="token function">mapToLong</span><span class="token punctuation">(</span> weigth <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span> <span class="token keyword">long</span> <span class="token punctuation">)</span><span class="token punctuation">(</span> weigth <span class="token operator">*</span> <span class="token number">100</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// LongStream</span>    <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span> percentage <span class="token operator">-</span><span class="token operator">></span> percentage <span class="token operator">+</span> <span class="token string">"%"</span> <span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Stream&lt; String> </span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span> Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// List&lt; String > </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> result <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>控制台输出结果如下：</p><pre><code>[19%, 50%, 30%]</code></pre><p>最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Path path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span> filename <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">(</span> Stream<span class="token operator">&lt;</span> String <span class="token operator">></span> lines <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span> path<span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8 <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    lines<span class="token punctuation">.</span><span class="token function">onClose</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Stream的方法<code>onClose()</code> 返回一个等价的有额外句柄的Stream，当Stream的<code>close()</code>方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。</p><h2 id="8-并行数组"><a href="#8-并行数组" class="headerlink" title="8. 并行数组"></a>8. 并行数组</h2><p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>parallel<span class="token punctuation">.</span>arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadLocalRandom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelArrays</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrayOfLong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span> <span class="token punctuation">[</span> <span class="token number">20000</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>                Arrays<span class="token punctuation">.</span><span class="token function">parallelSetAll</span><span class="token punctuation">(</span> arrayOfLong<span class="token punctuation">,</span>             index <span class="token operator">-</span><span class="token operator">></span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span> <span class="token number">1000000</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span> arrayOfLong <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>             i <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> i <span class="token operator">+</span> <span class="token string">" "</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">parallelSort</span><span class="token punctuation">(</span> arrayOfLong <span class="token punctuation">)</span><span class="token punctuation">;</span>                Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span> arrayOfLong <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>             i <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> i <span class="token operator">+</span> <span class="token string">" "</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p><pre><code>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16.04下搭建hadoop3.2.0</title>
      <link href="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/"/>
      <url>/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu16-04下搭建hadoop3-2-0"><a href="#Ubuntu16-04下搭建hadoop3-2-0" class="headerlink" title="Ubuntu16.04下搭建hadoop3.2.0"></a>Ubuntu16.04下搭建hadoop3.2.0</h1><p>这里搭建的是3个节点的完全分布式，即1个nameNode，2个dataNode，分别如下：</p><p>Ubuntu-master  nameNode  192.168.11.160</p><p>Ubuntu-node1  dataNode   192.168.11.161</p><p>Ubuntu-node2  dataNode   192.168..11.162</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>解压完成后sudo vim /etc/profile配置环境变量，配置如下：</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210057715.png" alt="image-20200509210057715"></p><p>保存退出，source /etc/profile         java  -version</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210118310.png" alt="image-20200509210118310"></p><h2 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h2><p>参考源：<a href="http://www.linuxdiyf.com/linux/20707.html" target="_blank" rel="noopener">http://www.linuxdiyf.com/linux/20707.html</a></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210350225.png" alt="image-20200509210350225"></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210357982.png" alt="image-20200509210357982"></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210406941.png" alt="image-20200509210406941"></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210417941.png" alt="image-20200509210417941"></p><hr><p><strong>保存后重启系统*</strong></p><h2 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h2><ol><li><p>输入 sudo mkdir /usr/local/hadoop 创建一个hadoop的文件夹</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210946158.png" alt="image-20200509210946158"></p></li><li><p>进入存放hadoop  jar包的目录，输入 sudo tar -zxvf hadoop-3.2.0.tar.gz -C /usr/local/hadoop解压tar包</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509210956932.png" alt="image-20200509210956932"></p></li><li><p>输入 sudo vi /etc/profile 或sudo vim /etc/profile，配置环境变量</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211005014.png" alt="image-20200509211005014"></p></li><li><p>加入如下内容，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211011440.png" alt="image-20200509211011440"></p></li><li><p>输入 source /etc/profile ，使环境变量生效</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211021471.png" alt="image-20200509211021471"></p></li><li><p>任意目录输入 hado ，然后按Tab，如果自动补全为hadoop，则说明环境变量配的没问题，否则检查环境变量哪出错了</p></li><li><p>创建3个之后要用到的文件夹，分别如下：</p><p>sudo mkdir /usr/local/hadoop/tmp</p><p>sudo mkdir -p /usr/local/hadoop/hdfs/name</p><p>sudo mkdir /usr/local/hadoop/hdfs/data</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211029586.png" alt="image-20200509211029586"></p></li><li><p>进入hadoop解压后的 /etc/hadoop 目录，里面存放的是hadoop的配置文件，接下来要修改这里面一些配置文件</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211039567.png" alt="image-20200509211039567"></p></li><li><p>有2个.sh文件，需要指定一下JAVA的目录，首先输入 sudo vim hadoop-env.sh 修改配置文件</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211059585.png" alt="image-20200509211059585"></p></li><li><p>解除原有的JAVA_HOME注释，根据自己的JDK安装位置，精确配置JAVA_HOME如下，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211109260.png" alt="image-20200509211109260"></p></li><li><p>输入 sudo vim yarn-env.sh 修改配置文件</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211116151.png" alt="image-20200509211116151"></p></li><li><p>加入如下内容，指定JAVA_HOME，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211123301.png" alt="image-20200509211123301"></p></li><li><p>输入 sudo vim core-site.xml 修改配置文件</p><pre><code>&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211200097.png" alt="image-20200509211200097"></p></li><li><p>输入 sudo vim hdfs-site.xml 修改配置文件</p><pre><code>&lt;property&gt;     &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;     &lt;value&gt;file:/usr/local/hadoop/hdfs/name&lt;/value&gt;&lt;/property&gt;&lt;property&gt;     &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;     &lt;value&gt;file:/usr/local/hadoop/hdfs/data&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;1&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211318134.png" alt="image-20200509211318134"></p></li><li><p>输入 sudo vim mapred-site.xml 修改配置文件</p><pre><code>&lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211342395.png" alt="image-20200509211342395"></p></li><li><p>输入 sudo vim yarn-site.xml 修改配置文件</p><pre><code>&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;master&lt;/value&gt;    &lt;description&gt;指定resourcemanager所在的hostname&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;description&gt;        NodeManager上运行的附属服务。        需配置成mapreduce_shuffle，才可运行MapReduce程序    &lt;/description&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211443936.png" alt="image-20200509211443936"></p></li><li><p>输入 sudo vim workers 修改配置文件</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211451486.png" alt="image-20200509211451486"></p></li><li><p>回到 /usr/local 目录下，输入 sudo chmod 777 -R hadoop/</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211500452.png" alt="image-20200509211500452"></p></li></ol><h2 id="安装SSH、配置SSH无密码登陆"><a href="#安装SSH、配置SSH无密码登陆" class="headerlink" title="安装SSH、配置SSH无密码登陆"></a>安装SSH、配置SSH无密码登陆</h2><ol><li><p>安装SSH</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211834682.png" alt="image-20200509211834682"></p></li><li><p>将虚拟机关闭，再复制两份虚拟机，重命名为如下，注意这里一定要关闭虚拟机，再复制</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211840666.png" alt="image-20200509211840666"></p></li><li><p>将3台虚拟机都打开，后两台复制的虚拟机打开时，都选择“我已复制该虚拟机”，复制后开启虚拟机，修改静态IP</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211846074.png" alt="image-20200509211846074"></p></li><li><p>在master机器上，输入 sudo vim /etc/hostname，将内容改为master，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211854398.png" alt="image-20200509211854398"></p></li><li><p>在node1机器上，输入 sudo vim /etc/hostname，将内容改为node1，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211901120.png" alt="image-20200509211901120"></p></li><li><p>在node2机器上，输入 vi /etc/hostname，将内容改为node2，保存并退出</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211906735.png" alt="image-20200509211906735"></p></li><li><p>在三台机器分别输入 vi /etc/hosts 修改文件，其作用是将一些常用的网址域名与其对应的IP地址建立一个关联，当用户在访问网址时，系统会首先自动从Hosts文件中寻找对应的IP地址</p></li><li><p>三个文件中都加入如下内容，保存并退出，注意这里要根据自己实际IP和节点主机名进行更改，IP和主机名中间要有一个空格</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211915840.png" alt="image-20200509211915840"></p></li><li><p>在每一节点上进行ssh免密登录（参考：<a href="http://dblab.xmu.edu.cn/blog/install-hadoop-cluster/）" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-hadoop-cluster/）</a></p><p>首先生成 Master 节点的公匙，在 Master 节点的终端中执行（因为改过主机名，所以还需要删掉原有的再重新生成一次）：</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211935526.png" alt="image-20200509211935526"></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211947289.png" alt="image-20200509211947289"></p><p>完成后可执行 ssh master 验证一下（可能需要输入 yes，成功后执行 exit 返回原来的终端）。接着在 Master 节点将上公匙传输到 node1 和 node2 节点：</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212442417.png" alt="image-20200509212442417"></p><p>scp 是 secure copy 的简写，用于在 Linux 下进行远程拷贝文件，类似于 cp 命令，不过 cp 只能在本机中拷贝。执行 scp 时会要求输入 node1，node2 上 kanshui 用户的密码(自定义的密码)，输入完成后会提示传输完毕，如下图所示：</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212448365.png" alt="image-20200509212448365"></p><p>接着在 node1,node2 节点上，将 ssh 公匙加入授权：</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/wps2.jpg" alt="img"> </p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/wps3.jpg" alt="img"></p></li><li><p>在master机器上输入 ssh master 测试免密码登陆</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212508365.png" alt="image-20200509212508365"></p><p>在master机器上，任意目录输入 hdfs namenode -format 格式化namenode，第一次使用需格式化一次，之后就不用再格式化，如果改一些配置文件了，可能还需要再次格式化</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212604236.png" alt="image-20200509212604236"></p><p>开启hadoop</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212611045.png" alt="image-20200509212611045"></p><p>在master节点验证</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509212617819.png" alt="image-20200509212617819"></p><p>node1,node2节点验证</p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/wps4.jpg" alt="img"></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/wps5.jpg" alt="img"></p></li></ol><h2 id="浏览器查看"><a href="#浏览器查看" class="headerlink" title="浏览器查看"></a>浏览器查看</h2><p><a href="http://192.168.11.160:9870" target="_blank" rel="noopener">http://192.168.11.160:9870</a></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211805932.png" alt="image-20200509211805932"></p><p><a href="http://192.168.11.160:8088" target="_blank" rel="noopener">http://192.168.11.160:8088</a></p><p><img src="/2020/05/09/ubuntu16-04-xia-da-jian-hadoop3-2-0/image-20200509211819940.png" alt="image-20200509211819940"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven工程变灰色解决方法</title>
      <link href="/2020/05/09/maven-gong-cheng-bian-hui-se-jie-jue-fang-fa/"/>
      <url>/2020/05/09/maven-gong-cheng-bian-hui-se-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven工程变灰色解决方法"><a href="#Maven工程变灰色解决方法" class="headerlink" title="Maven工程变灰色解决方法"></a>Maven工程变灰色解决方法</h1><p>在使用idea的过程中，遇到其中一个maven模块变成灰色，如下所示：</p><p><img src="/2020/05/09/maven-gong-cheng-bian-hui-se-jie-jue-fang-fa/image-20200509205143629.png" alt="image-20200509205143629"></p><p>​        造成这个的原因可能是忽略了maven模块，可以尝试如下解决方法：在idea中maven的setting中找到ignored files,看右边的面板中是否将变灰的maven模块忽略了。我的模块变灰就是因为这个原因，Settings–&gt;Maven–&gt;Ignored Files 看看是不是有勾选的。去掉就好了。</p><p><img src="/2020/05/09/maven-gong-cheng-bian-hui-se-jie-jue-fang-fa/image-20200509205212747.png" alt="image-20200509205212747"></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2020/05/08/xuan-ze-pai-xu/"/>
      <url>/2020/05/08/xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序-java实现"><a href="#选择排序-java实现" class="headerlink" title="选择排序(java实现)"></a>选择排序(java实现)</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>  在数组中，</p><p>在0 ~ N-1 找到最小的元素放到0位置上</p><p>在1 ~ N-1 找到最小的元素放到1位置上</p><p>在2 ~ N-1 找到最小的元素放到1位置上</p><p>​                     。。。。。。。</p><p>直至最后</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  * @author cxr * 选择排序 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_SelectSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> minIndex <span class="token operator">:</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//            int tmp = arr[minIndex];</span><span class="token comment" spellcheck="true">//            arr[minIndex] = arr[i];</span><span class="token comment" spellcheck="true">//            arr[i] = tmp;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">62</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Code_SelectSort<span class="token punctuation">.</span><span class="token function">selectSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7-hadoop3.2.0环境搭建</title>
      <link href="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/"/>
      <url>/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7下搭建hadoop3-2-0完全分布式"><a href="#CentOS7下搭建hadoop3-2-0完全分布式" class="headerlink" title="CentOS7下搭建hadoop3.2.0完全分布式"></a>CentOS7下搭建hadoop3.2.0完全分布式</h1><p>（全程使用root用户操作）</p><p>这里搭建的是3个节点的完全分布式，即1个nameNode，2个dataNode，分别如下：</p><p>CentOS-master  nameNode  192.168.11.140</p><p>CentOS-node1  dataNode   192.168.11.141</p><p>CentOS-node2  dataNode   192.168..11.142</p><p>参考源：<a href="https://www.cnblogs.com/andy6/p/7440804.html" target="_blank" rel="noopener">https://www.cnblogs.com/andy6/p/7440804.html</a></p><p>实验环境：</p><p>​    Vmware12 </p><p>软件版本：</p><p>​    jdk-8u181-linux-x64.tar.gz ，hadoop-3.2.0</p><p>一、 实现步骤:</p><ol><li>首先创建好一个CentOS虚拟机，将它作为主节点我这里起名为CentOS-master，起什么都行，不固定要求</li></ol><ol start="2"><li><p>虚拟机安装完成后，配置静态IP（以下网络配置图片来自参考网址）</p><p>详细配置步骤可参考以下博客：</p><p><a href="https://blog.csdn.net/aafeiyang/article/details/81533542" target="_blank" rel="noopener">https://blog.csdn.net/aafeiyang/article/details/81533542</a></p></li></ol><p>   第一步：</p><p>   第二步：</p><p>   第三步：</p><p>   第四步：修改一个配置文件（ifcfg-ens33这个文件不同的电脑可能文件名字不一样）</p><p>   ​       <strong>vim /etc/sysconfig/network-scripts/ifcfg-ens33</strong></p><pre><code>   DEVICE=&quot;eth0&quot;   BOOTPROTO=&quot;static&quot;  &lt;!--将原来的dhcp改成&quot;static&quot;--&gt;   HWADDR=&quot;00:0C:29:83:7F:54&quot;   IPV6INIT=&quot;yes&quot;   NM_CONTROLLED=&quot;yes&quot;   ONBOOT=&quot;yes&quot;    &lt;!--这儿要将&quot;no&quot;改成&quot;yes&quot;--&gt;   TYPE=&quot;Ethernet&quot;   UUID=&quot;aae85c0a-42db-4772-b940-0fc9c875afd2&quot;   IPADDR=192.168.174.10   &lt;!--IP地址配一个自己想要配的地址，但是必须是同VMnet8的子网IP在同一网段--&gt;   GATEWAY=192.168.174.2 &lt;!--网关，这个值与我们在“NAT（设置S）...”设置的网关一样--&gt;   NETMASK=255.255.255.0  &lt;!--子网掩码--&gt;   DNS1=192.168.174.2         &lt;!--DNS的值也跟我们“NAT（设置）...”设置的的网关一样--&gt;</code></pre><p>   第五步：重启虚拟机</p><ol start="3"><li><p>安装和配置jdk</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/wps4.jpg" alt="img"> </p></li></ol><p>   <img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/wps5.jpg" alt="img"></p><ol start="4"><li><p>输入 systemctl stop firewalld.service ，关闭防火墙</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508161020198.png" alt="image-20200508161020198"></p></li><li><p>输入 systemctl disable firewalld.service ，禁用防火墙</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508161014673.png" alt="image-20200508161014673"></p></li><li><p>输入 mkdir /usr/local/hadoop 创建一个hadoop的文件夹</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508161011052.png" alt="image-20200508161011052"></p></li><li><p>进入存放hadoop  jar包的目录，输入 tar -zxvf hadoop-3.2.0.tar.gz -C /usr/local/hadoop解压tar包</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160952891.png" alt="image-20200508160952891"></p></li><li><p>输入 vim /etc/profile 或vim /etc/profile，配置环境变量</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160949817.png" alt="image-20200508160949817"></p></li><li><p>加入如下内容，保存并退出</p><p>HADOOP_HOME=/usr/local/hadoop/hadoop-3.2.0/</p><p>PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160928274.png" alt="image-20200508160928274"></p></li><li><p>输入 source /etc/profile ，使环境变量生效</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160923977.png" alt="image-20200508160923977"></p></li><li><p>任意目录输入 hado ，然后按Tab，如果自动补全为hadoop，则说明环境变量配的没问题，否则检查环境变量哪出错了</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160919536.png" alt="image-20200508160919536"></p></li><li><p>创建3个之后要用到的文件夹，分别如下：</p><p>mkdir /usr/local/hadoop/tmp</p><p>mkdir -p /usr/local/hadoop/hdfs/name</p><p>mkdir /usr/local/hadoop/hdfs/data</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160914134.png" alt="image-20200508160914134"></p></li><li><p>进入hadoop解压后的 /etc/hadoop 目录，里面存放的是hadoop的配置文件，接下来要修改这里面一些配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160907935.png" alt="image-20200508160907935"></p></li><li><p>有2个.sh文件，需要指定一下JAVA的目录，首先输入 vim hadoop-env.sh 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160903295.png" alt="image-20200508160903295"></p></li><li><p>找到JAVA_HOME注释区，去掉注释，根据自己的JDK安装位置，精确配置JAVA_HOME如下，保存并退出</p><p>export JAVA_HOME=/opt/java/jdk1.8.0_181/</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160857709.png" alt="image-20200508160857709"></p></li><li><p>输入 vim yarn-env.sh 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160847083.png" alt="image-20200508160847083"></p></li><li><p>在文件头加入如下内容，指定JAVA_HOME，保存并退出</p><p>export JAVA_HOME=/opt/java/jdk1.8.0_181/</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160833139.png" alt="image-20200508160833139"></p></li><li><p>输入 vim core-site.xml 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160827118.png" alt="image-20200508160827118"></p></li><li><p>在configuration标签中，添加如下内容，保存并退出，注意这里配置的hdfs:master:9000是不能在浏览器访问的</p><pre><code>&lt;property&gt;    &lt;name&gt; fs.default.name &lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160818214.png" alt="image-20200508160818214"></p></li><li><p>输入 vim hdfs-site.xml 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160813085.png" alt="image-20200508160813085"></p></li><li><p>在configuration标签中，添加如下内容，保存并退出</p><pre><code>&lt;property&gt;     &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;     &lt;value&gt;file:/usr/local/hadoop/hdfs/name&lt;/value&gt;&lt;/property&gt;&lt;property&gt;      &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;      &lt;value&gt;file:/usr/local/hadoop/hdfs/data&lt;/value&gt;&lt;/property&gt;&lt;property&gt;      &lt;name&gt;dfs.replication&lt;/name&gt;      &lt;value&gt;1&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160807726.png" alt="image-20200508160807726"></p></li><li><p>输入 vim mapred-site.xml 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160800472.png" alt="image-20200508160800472"></p></li><li><p>在configuration标签中，添加如下内容，保存并退出</p><pre><code>&lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160754267.png" alt="image-20200508160754267"></p></li><li><p>输入 vim yarn-site.xml 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160742937.png" alt="image-20200508160742937"></p></li><li><p>在configuration标签中，添加如下内容，保存并退出</p><pre><code>&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;master&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;</code></pre><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160735620.png" alt="image-20200508160735620"></p></li><li><p>输入 vim workers 修改配置文件</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160730425.png" alt="image-20200508160730425"></p></li><li><p>将localhost删掉，加入如下内容，即dataNode节点的主机名</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160725303.png" alt="image-20200508160725303"></p></li><li><p>将虚拟机关闭，再复制两份虚拟机，重命名为如下，注意这里一定要关闭虚拟机，再复制</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160718744.png" alt="image-20200508160718744"></p></li><li><p>将3台虚拟机都打开，后两台复制的虚拟机打开时，都选择“我已复制该虚拟机”</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160715055.png" alt="image-20200508160715055"></p></li><li><p>将node1的IP地址改为192.168.11.141，    将node2 IP地址改为192.168.11.142</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160709310.png" alt="image-20200508160709310"></p></li><li><p>在master机器上，输入 vim /etc/hostname，将localhost改为master，保存并退出</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160703419.png" alt="image-20200508160703419"></p></li><li><p>在node1机器上，输入 vim /etc/hostname，将localhost改为node1，保存并退出</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160657723.png" alt="image-20200508160657723"></p></li><li><p>在node2机器上，输入 vim /etc/hostname，将localhost改为node2，保存并退出</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160650455.png" alt="image-20200508160650455"></p></li><li><p>在三台机器分别输入 vim /etc/hosts 修改文件，其作用是将一些常用的网址域名与其对应的IP地址建立一个关联，当用户在访问网址时，系统会首先自动从Hosts文件中寻找对应的IP地址</p></li><li><p>三个文件中都加入如下内容，保存并退出，注意这里要根据自己实际IP和节点主机名进行更改，IP和主机名中间要有一个空格</p><p>192.168.11.140 master</p><p>192.168.11.141 node1</p><p>192.168.11.142 node2</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160643833.png" alt="image-20200508160643833"></p></li><li><p>在master机器上输入 ssh-keygen -t dsa -P ‘’ -f ~/.ssh/id_dsa 创建一个无密码的公钥，-t是类型的意思，dsa是生成的密钥类型，-P是密码，’’表示无密码，-f后是秘钥生成后保存的位置</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160637143.png" alt="image-20200508160637143"></p></li><li><p>在master机器上输入 cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 将公钥id_dsa.pub添加进keys，这样就可以实现无密登陆ssh</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160630628.png" alt="image-20200508160630628"></p></li><li><p>在master机器上输入 ssh master 测试免密码登陆</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160625477.png" alt="image-20200508160625477"></p></li><li><p>如果有询问，则输入 yes ，回车</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160620349.png" alt="image-20200508160620349"></p></li><li><p>在node1主机上执行 mkdir ~/.ssh</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160616568.png" alt="image-20200508160616568"></p></li><li><p>在node2主机上执行 mkdir ~/.ssh</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160610928.png" alt="image-20200508160610928"></p></li><li><p>在master机器上输入 scp <del>/.ssh/authorized_keys root@node1:</del>/.ssh/authorized_keys 将主节点的公钥信息导入node1节点，导入时要输入一下node1机器的登陆密码</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160604749.png" alt="image-20200508160604749"></p></li><li><p>在master机器上输入 scp <del>/.ssh/authorized_keys root@node2:</del>/.ssh/authorized_keys 将主节点的公钥信息导入node2节点，导入时要输入一下node2机器的登陆密码</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160559286.png" alt="image-20200508160559286"></p></li><li><p>在三台机器上分别执行 chmod 600 ~/.ssh/authorized_keys 赋予密钥文件权限</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/wps1.jpg" alt="img"></p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/wps2.jpg" alt="img"> </p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/wps3.jpg" alt="img"></p></li><li><p>在master节点上分别输入 ssh node1 和 ssh node2 测试是否配置ssh成功</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160539731.png" alt="image-20200508160539731"></p></li><li><p>在master机器上，任意目录输入 hdfs namenode -format 格式化namenode，第一次使用需格式化一次，之后就不用再格式化，如果改一些配置文件了，可能还需要再次格式化</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160532722.png" alt="image-20200508160532722"></p></li><li><p>格式化完成</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160526052.png" alt="image-20200508160526052"></p></li><li><p>在master机器上，进入hadoop的sbin目录，输入 ./start-all.sh 启动hadoop</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160510421.png" alt="image-20200508160510421">)<img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160515446.png" alt="image-20200508160515446">)<img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160519165.png" alt="image-20200508160519165"></p><p><em>如果报错</em></p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160502322.png" alt="image-20200508160502322"></p></li></ol><pre><code>***修改以下4个文件：***在/usr/local/hadoop/Hadoop-3.2.0/sbin路径下： 将start-dfs.sh，stop-dfs.sh两个文件顶部添加以下参数```</code></pre><p>#!/usr/bin/env bash</p><pre><code>HDFS_DATANODE_USER=rootHADOOP_DATANODE_SECURE_USER=hdfsHDFS_NAMENODE_USER=rootHDFS_SECONDARYNAMENODE_USER=root```还有，start-yarn.sh，stop-yarn.sh顶部也需添加以下参数：```</code></pre><p>#!/usr/bin/env bash</p><pre><code>YARN_RESOURCEMANAGER_USER=rootHADOOP_SECURE_DN_USER=yarnYARN_NODEMANAGER_USER=root```修改后重启 start-all.sh</code></pre><ol start="49"><li><p>输入 jps 查看当前java的进程，该命令是JDK1.5开始有的，作用是列出当前java进程的PID和Java主类名，nameNode节点除了JPS，还有3个进程，启动成功</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160442709.png" alt="image-20200508160442709"></p></li><li><p>在node1机器和node2机器上分别输入 jps 查看进程如下，说明配置成功</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160425107.png" alt="image-20200508160425107">)<img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160430270.png" alt="image-20200508160430270"></p></li><li><p>在浏览器访问nameNode节点的8088端口和9870端口可以查看hadoop的运行状况</p><p><img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160402263.png" alt="image-20200508160402263">)<img src="/2020/05/08/centos7-hadoop3-2-0-huan-jing-da-jian/image-20200508160415831.png" alt="image-20200508160415831"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序(java实现)</title>
      <link href="/2020/05/07/mou-pao-pai-xu-java-shi-xian/"/>
      <url>/2020/05/07/mou-pao-pai-xu-java-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>数组 [3,2,6,0,7]</p><p>下标   0 1 2 3 4</p><p>​    如果0位置上的数比1位置上的数大，两个数交换，否则不换，以此类推，之后每两个数相比较，最后，数组中最大的数就会到达数组最后的位置上；即每次都是相邻的两个数作比较，直至排序成功。</p><p>代码实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  * @author cxr *    冒泡排序 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_BubbleSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> end<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">62</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Code_BubbleSort<span class="token punctuation">.</span><span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/06/hello-world/"/>
      <url>/2020/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
